There are two approaches to evaluating two data points within 1 call of the custom instruction. The data points can either be evaluated sequentially or they can be evaluated in parallel. One of the design considerations states that the amount of resources should be minimised, however if resources can be traded for a reduction in latency, then the design that reduces latency will be preferred. Processing the data points sequentially will increase the latency, albeit not significantly. As such, the two data points will be evaluated in parallel.\\

Secondly, it was noted that the design in section \ref{sec:task7_overall} only performed 1 iteration of the cordic algorithm each clock cycle. This is an extremely inefficient implementation. Processing 1 iteration of the cordic algorithm using combinations logic does not take $20ns$. To reduce the latency of the program, it is preferable to use as much of each clock cycle to perform computations, i.e to minimise the slack time. The design in section \ref{sec:task7_overall} spends a large proportion of each clock cycle idle. As such, more iterations of the cordic algorithm should be performed each clock cycle. \\

If all 31 iterations were performed in 1 clock cycle, the critical path of the combinatorial logic will be too long; the design will need a clock that is slower than $50Mhz$. To reduce the length of the critical path, registers can be added to hold intermediary values. This is called pipelining. 
 